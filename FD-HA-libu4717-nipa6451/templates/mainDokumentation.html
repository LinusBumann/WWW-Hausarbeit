{% extends 'layout.html' %} {%block content%}

<main class="mainDokuText">
  <div class="ueberschrift"><h1>Dokumentation</h1></div>
  <ol class="LinusName">
    <li>Name: Linus Bumann</li>
    <li>Matrikelnummer: 690869</li>
    <li>Login: libu4717</li>
  </ol>
  <ol class="NicoName">
    <li>Name: Nico Paulsen</li>
    <li>Matrikelnummer: 671112</li>
    <li>Login: nipa6451</li>
  </ol>
  <ol class="list1">
    <h1>Frontend</h1>
    <li>
      <h2>Ideen und Konzepte</h2>
      <p>
        Was die Idee und das Konzept der Seite angeht haben wir uns an der
        Frontend-Hausarbeit aus dem letzten Semester orientiert, da wir diese
        für das Frontend genutzt und um das Backend erweitert haben. Unsere
        Webseite verfolgt das allgemeine Ziel dem Besucher Informationen über
        bestimmte Schuhe und weitere Dinge zur Verfügung zu stellen. Zusätzlich
        dazu sollen Nutzer, die sich einen Account erstellt haben, auch Schuhe
        bearbeiten können. Dabei verfolgt die Seite den Ansatz eines etwas
        eingeschrenkten Wikis inzwischen. Nur Admins können Schuhe hinzufügen,
        aber Nutzer diese eben bearbeiten, falls dort Fehler im Text sind.
      </p>
    </li>
    <li>
      <h2>Nunjucksaufbau</h2>
      <p>
        Zum Rendern der einzelnen HTML-Seiten setzten wir Nunjucks ein. Dabei
        haben wir eine grundsätzliche layout.html erstellt. Diese enthält den
        head und body. Im body wird von der layout.html dann noch der header und
        der footer angezeigt. Der header enthält dann unsere Navbar. Dort wird
        dann nach Status des Logins entweder "Login" oder "Profil" gerendert,
        gesteuert durch ein Nunjucks-"if". Dann wird mittels "block content",
        "endblock" signalisiert, dass hier der variable Content der Seite
        angezeigt werden soll. Unser Header und footer sind also immer gleich.
        Der "block content", "endblock" enthält dann den Teil des HTML, der in
        anderen HTML-Dateien festgelegt wird. Diese HTML-Dateien enthalten dann
        einen "extends layout.html" und dann "block content", "endblock". Dieser
        Teil wird dann also an der Position in der layout.html angezeigt. Je
        nach Seite wird dann mit Nunjucks-Befehlen die passenden Inhalte
        angezeigt.
      </p>
    </li>
    <li>
      <h2>Styletiles</h2>
      <p>
        Wir haben insgesamt vier verschiedene Styletiles entworfen. Dabei haben
        wir uns weiterhin, wie auch in der Frontend-Hausarbeit am 3. Styletile
        orientiert.
      </p>
    </li>
    <li>
      <h2>Fertiger Seitenaufbau</h2>
      <ol class="list2">
        <p>Aufbau der fertigen Website</p>
        <ul class="list3">
          <li>
            <p>Startseite</p>
            <ul class="list4">
              <li><p>Großes Bild mit Webseitenname</p></li>
              <li>
                <p>Navbar</p>
                <ul class="list5">
                  <li><p>Webseitenname (Homebutton)</p></li>
                  <li><p>Marken (Nike, Adidas)</p></li>
                  <li><p>About Us</p></li>
                  <li>
                    <p>Profil/Login, der sich abwechselt, je nach Status</p>
                  </li>
                </ul>
              </li>
              <li>
                <p>Erste Infoboxen</p>
                <ul class="list5">
                  <li><p>Nike</p></li>
                  <li><p>Adidas</p></li>
                </ul>
              </li>
              <li><p>Footer</p></li>
            </ul>
          </li>
          <li>
            <p>Markenunterseite</p>
            <ul class="list4">
              <li>
                <p>Segmente</p>
                <ul class="list5">
                  <li>
                    <p>Auswahl von verschiedenen Schuh-Modelle</p>
                  </li>
                </ul>
              </li>
              <li><p>Footer</p></li>
            </ul>
          </li>
          <li>
            <p>Seite mit den genauen Informationen</p>
            <ul class="list4">
              <li><p>Bilder der Objekte</p></li>
              <li><p>Infotexte zu den Objekten</p></li>
              <li>
                <p>
                  Wenn man als Admin eingelogt ist: Bearbeiten, Entfernen und
                  Hinzufügen der Schuhe
                </p>
              </li>
              <li>
                <p>
                  Wenn man als normaler Nutzer eingelogt ist: Bearbeiten der
                  Schuhe
                </p>
              </li>
            </ul>
          </li>
          <li>
            <p>About Us</p>
            <ul class="list4">
              <li><p>Namen</p></li>
              <li><p>Instagram</p></li>
              <li><p>FAQ</p></li>
              <li><p>Beschreibung der Seite</p></li>
            </ul>
          </li>
          <li>
            <p>Login</p>
            <ul class="list4">
              <li><p>E-Mail Eingabefeld</p></li>
              <li><p>Passwort Eingabefeld</p></li>
              <li><p>Button zum einloggen</p></li>
            </ul>
          </li>
          <li>
            <p>Profilseite</p>
            <ul class="list4">
              <li><p>Anzeige von Vorname, Nachnahme und E-Mail</p></li>
              <li><p>Logout-Button</p></li>
            </ul>
          </li>
          <li>
            <p>Schuhe Bearbeiten-Seite</p>
            <ul class="list4">
              <li><p>Eingabefeld: Schuhname</p></li>
              <li><p>Feld zum Bild hochladen</p></li>
              <li><p>Eingabefeld: Beschreibungstext</p></li>
              <li><p>Eingabefeld: Kommentar zum Schuh</p></li>
            </ul>
          </li>
          <li>
            <p>Schuhe Entfernen-Seite</p>
            <ul class="list4">
              <li>
                <p>
                  Eingabefeld für den Namen des Schuhs, der entfertn werden soll
                </p>
              </li>
            </ul>
          </li>
          <li>
            <p>Schuhe Hinzufügen-Seite</p>
            <ul class="list4">
              <li><p>Eingabefeld: Schuhname</p></li>
              <li><p>Eingabefeld: Baureihe</p></li>
              <li><p>Feld zum Bild hochladen</p></li>
              <li><p>Eingabefeld: Beschreibungstext</p></li>
              <li><p>Eingabefeld: Kommentar zum Schuh</p></li>
            </ul>
          </li>
        </ul>
      </ol>
    </li>

    <li>
      <h2>Auswahl der Fonts</h2>
      <p>
        Bei der Auswahl der Fonts haben wir uns das Ziel gesetzt zwei Fonts zu
        finden, die sich stärker von einander unterscheiden. Dies hat vor allem
        den Grund, dass die Überschriften sich stark vom den
        informationvermittelnden Inhaltstexten unterscheiden sollen. Deswegen
        nutzen wir für die großen Überschriften "Lobster", für die großen
        Überschriften, und für die Fließtexte "Lato", ein serifenlosen Font für
        Unterüberschriften und Fließtexte. Dies lockert das sonst auch „cleane“
        Design etwas auf. Durch die grundverschiedenen Fonst soll die Webseite
        etwas aufregender werden.
      </p>
    </li>
    <li>
      <h2>Auswahl der Farben</h2>
      <p>
        Bei den Farben haben wir uns an neutralen Farben/Kontrasten orientiert.
        Diese sind Schwarz, Weiß und Grau. Uns ist aber von Anfang an klar
        gewesen, dass die reine Nutzung dieser drei Farben die Seite zu trist
        wirken lässt.
      </p>
    </li>
    <li>
      <h2>Auswahl des Layouts/Rasters</h2>
      <p>
        Unser Layout folgt bis auf der Seite, wo die Infos dargestellt werden
        dem gleichen Schema. Ganz oben wird ein Bild mit Überschirft dargestellt
        und darunter wird dann in Kästchen je nach Thema ein passendes Bild plus
        kleinen Infotext und „Mehr Anzeigen“-Button dargestellt. In der
        Desktopversion wird der Text und der Button erst beim Hovern über dem
        Kästchen angezeigt um sich von der Mobilversion etwas ab zu heben und
        die Möglichkeit der Funktion voll aus zu schöpfen. Dieses Grundlayout
        wird bis auf die Seite mit den genauen Infos genutzt, um eine schnelle
        Navigation zu gewährleisten. Auf der Infoseite wird dann mit diesem
        Layout gebrochen, da es sich nicht so gut für die Darstellung der
        Infotexte eignet. Dort wird dann ein Bild plus dauerhaft angezeigten
        Infotext verwendet, welches aber wieder von einem Kasten umrahmt ist, um
        die Inhalte gut von einander trennen zu können. In der Desktopversion
        schiebt sich das Bild beim Hovern dann entweder links oder rechts neben
        den Text. Dies soll die Seite etwas auflockern und dafür sorgen, dass es
        nicht nach einer langweiligen Auflistung aussieht. Trotzdem bleibt im
        Grunde das Grundlayout aber erhalten, da die Seite imaginär wieder in
        kleine Boxen aufgeteilt werden kann.
      </p>
    </li>
    <li>
      <h2>Einsatz von Mediaqueries für Responsive Webdesign</h2>
      <p>
        Wir nutzen auf unserer Seite zwei zusätzliche Mediaqueries um unsere
        Seite an Tablet, und Desktopgrößen an zu passen. Alle Layouts verfolgen
        dabei den gleichen Grundansatz, dass Boxen neben- oder untereinander
        angeordnet werden. In der Mobileversion werden aufgrund des Platzmangels
        alle Inhalte immer untereinander dargestellt. Dies führt auch dazu, dass
        nicht zu viele Inhalte auf einmal angezeigt werden. Dadurch kann die
        Schrift etwas größer sein, was zu einer besseren Lesbarkeit auf dem
        Mobilgerät führt. Sobald der Platz wächst ist es uns dann möglich die
        Inhalte auch nebeneinander dar zu stellen. Das gilt nicht nur für die
        Boxen, sondern auch die Inhalte in den Boxen. In der Mobileversion wird
        in der Box ganz oben das Logo/Bild, dann ein kleiner Infotext und dann
        der „Mehr Anzeigen“-Button dargestellt. Sobald wir in die nächst größere
        Mediaquerie kommen werden aufgrund des entstandenen Platzes die Inhalte
        in der Box so angezeigt, dass der entstandene Weißraum wieder
        vollständig genutzt wird. Auf den Seiten mit den Infos über die
        einzelnen Modelle verfolgen wir das gleiche Prinzip. In der
        Mobileversion werden alle Inhalte untereinander dargestellt. Sobald der
        Bildschirm breiter wird verschiebt sich der Text neben das Bild um den
        entstandenen Raum wieder nutzen zu können.
      </p>
    </li>
    <li>
      <h2>Erläuterung zur "HTML-pur"-Datei</h2>
      <p>
        In der "HTML-pur"-Datei befinden sich unsere Navigationsleiste, ein
        Segment unserer Boxen, die wir auf der Seite nutzen, sowie der Footer,
        den wir entworfen haben. Dabei wird auf alle Texte und Links verzichtet,
        um die Übersicht des Dokuments zu erhöhen.
      </p>
    </li>
    <li>
      <h2>Disclaimer zu den Bildrechten und der Nutzung der Webseite</h2>
      <p>
        Zum Zeitpunkt der Erstellung unserer Webseite liegt uns keine
        Genehmigung zur Nutzung der Bilder vor. Somit darf diese Seite nicht
        veröffentlicht oder in jeglicher öffentlicher Form genutzt werden.
        Nutzung des Codes ist ohne die Verwendung der Bilder jedoch jederzeit
        möglich.
        <a href="/kollophon">Hier geht es zum Kolophon</a>
      </p>
      <p>
        <a href="/Erklärung-libu4717">Erklärung: Linus Bumann / </a>
        <a href="/Erklärung-nipa6451">Erklärung: Nico Paulsen</a>
      </p>
    </li>
    <h1>Backend</h1>
    <li>
      <h2>Konzepte</h2>
      <p>
        Im Backend haben wir uns an den Aufbau aus den Laboraufgaben gehalten.
        Zur Steuerung der Seite haben wir die server.js, app.js, controller.js,
        form-controller.js und die model.js verwendet. Für die Daten unserer
        Seite, die Veränderbar sind, haben wir dann noch eine Datenbank mit den
        passenden Tabellen angelegt.
      </p>
    </li>
    <li>
      <h2>server.js</h2>
      <p>Die server.js sorgt dafür, dass unsere Seite gesartet werden kann.</p>
    </li>
    <li>
      <h2>app.js</h2>
      <p>
        Die app.js enthält folgende Komponenten: Router-Funktion,
        serveStaticFile-Funktion, createID-Funktion, getSessionNutzer-Funktion
        und die handleRequest-Funktion. Die handleRequest-Funktion sorgt dafür,
        dass alle Anfragen, die auf der Seite gestellt werden, richtig
        verarbeitet werden. Zunächst öffnen wir aber die Datenbank, damit die
        handleRequest diese auch nutzen kann. In der handleRequest wird dann das
        ctx-Objekt erstellt, dass alle wichtigen Daten enthält. Danach wird dann
        überprüft, ob eine sessionID vorhanden ist, die dann in das ctx-Objekt
        gespeichert wird. Dann wird die getSessionNutzer(ctx) aufgerufen. Die
        überprüft, ob eine Session gerade aktiv ist, also ein Nutzer eingelogt
        ist. Ist dies der Fall wird der Nutzer in das ctx-Objekt gespeichert,
        sonst ist dieser "undefined", also nicht eingelogt. Das wird später auch
        noch im Router für bestimmte Weiterleitungen genutzt. Als nächstes rufen
        wir dann die serveStaticFile(base, ctx) auf. Die Base sorgt dafür, dass
        die Funktion auch nur in dem Ordner, bei uns assets, Bilder und das CSS
        holt. Dann rufen wir die router() auf. Diese überprüft dann anhand der
        url, ob es diese gibt. Falls es diese nicht gibt, wird man auf die
        404-Errorseite geleitet. Gibt es den pathname rufen wir die passende
        Funktion im controller oder form-controller auf. Diese erläutern wir
        später. Der router sorgt also dafür, dass die richtige Seite aufgerufen
        werden kann.
      </p>
    </li>
    <li>
      <h2>controller.js</h2>
      <p>
        Die Funktionen des controllers werden durch den Router aufgerufen. Diese
        steuern dann den Aufruf der passenden HTML-Seite mit zusätzlichen
        Parametern, falls diese nötig sind. Dabei ist der Aufbau immer der
        gleiche. Zunächst wird der ctx.respones.body gesetzt. Dieser enthält
        dann den render der jeweiligen HTML-Datei, die zusätzlich den Nutzer
        übergeben bekommt. Dann wird der Status der Anfrage und der Header
        gesetzt. Dies wird dann im ctx-Objekt returnt. Je nach Art der Seite
        werden dann noch weitere Daten in den respones.body übergeben, wie z.B.
        verschiedene IDs oder ähnliches, die nötig sind, um die richtigen
        Komponenten zu rendern. Der Nutzer wird aber immer mit übergeben, da
        sich durch diesen Entscheidet welche Buttons oder Elemente in der Navbar
        angezeigt werden. Z.B. wenn man von der Index in die Markenseite
        wechselt muss dann zusätzlich eine Funktion auf dem Model aufgerufen
        werden. In dem Beispiel wird dann in das const-Objekt der passende
        Hersteller gespeichert. Diese sind mit IDs in der Datenbank gespeichert.
        Damit wir in die Modelfunktion auch die richtige ID übergeben wird im
        Router in der app.js vorher die ID durch einen split der URL passend
        ausgelesen und in ctx.params.herstellerID gespeichert. Dadruch ist es
        dann möglich diesen params an die Modellfunktion zu übergeben. Diese
        liefert dann die passende ID die dann in dbData gespeichert wird. Dieses
        Vorgehen wird in jeder Funktion durchgeführt, in der IDs nötig sind. Die
        Funktion aus dem Model variiert dabei natürlich.
      </p>
    </li>
    <li>
      <h2>form-controller.js</h2>
      <p>
        Die form-controller ist für die Steuerung nötig, die für Formulare der
        Webseite genutzt werden. Beim Login zum Beispiel steuert die passende
        Funktion, den POST des Logins, also das senden der Daten an den Server,
        die der Nutzer eingegeben hat, um sich ein zu loggen. Im Router muss
        dabei unterschieden werden, ob es sich um ein GET oder POST handelt. Bei
        GET wird die Seite lediglich gerendert, beim POST wird dann die Funktion
        aufgerufen, die Daten an den Server schickt. Um an die Daten aus dem
        Formular ran zu kommen werden diese Daten zunächst im ein const formData
        gespeichert. Dann erstellen wir uns ein Objekt und speichern in die
        Komponenten dieses dann die passenden Eintäge des Formulars durch
        formData.get. Um dann für den Login das Passwort des Nutzers zu erhalten
        rufen wir eine Funktion aus dem Model auf, die uns dieses anhander der
        passenden Parameter liefert. Dieses wird dann mit dem Passwort der
        E-Mail aus der Datenbank verglichen. Ist dieses gleich wird eine Session
        erstellt, der User also eingeloggt. Ist dies nicht der Fall wird ein
        Fehler auf der Seite ausgegeben und der User kann sich nicht einloggen.
        Die Funktionen holen sich also immer als erstes die Daten aus dem
        Formular, rufen eine Funktion aus dem model.js auf und führen dann
        weitere, je nach Funktion, spezielle Schritte aus. Zusätzlich dazu haben
        wir noch drei Funktionen geschrieben, die für den Upload von Bildern
        bestimmt sind. Dabei wird die validateImage() immer dann aufgerufen,
        wenn ein Bild hochgeladen wird und überprüft ob dieses vorhadnen ist.
        Zusätzlich ruft diese wiederrum die isMimetypeOK() auf, die überprüft,
        ob das Bild als Format "jpep", "png", oder "svg" hat, da wir nur diese
        Formate haben möchten. Ist das Bild dann valide generieren wir mit
        generateFilename() einen zufälligen Dateinamen, damit andere Bilder
        nicht überschrieben werden. Danach wird das Bild dann noch in den
        richtigen Ordner, bei uns "Bilder", geschoben.
      </p>
    </li>
    <li>
      <h2>model.js</h2>
      <p>
        Die model.js ist dafür da, an die die Funktionen, die Funktionen aus der
        model.js aufrufen, die passenden Daten zurück zu liefern. Dies passiert
        dann mittels SQL-Befehlen, die die richtigen Daten aus unserer Datenbank
        holen. Die addRegister() wird z.B. in der form-controller.js aufgerufen,
        wenn sich ein Nutzer registrieren möchte. Zunächst wird das eingegebene
        Passwort des Nutzers in einen Hashwert umgewandelt. Dann wird der
        passende SQL-Befehl ausgeführt, der die Daten des Nutzers in der
        richtigen Tabelle in der Datenbank speichert. Eine andere SQL-Abfrage
        erfolgt z.B. in der getSchuhID(). Dort wird zunächst die query
        festgelegt. In diesem Fall sollen alle Schuhe ausgewählt werden, die die
        passende SchuhID besitzen. Im WHERE wird dann ein Platzhalter genutzt.
        So können SQL-Injektions verhindert werden. Der return gibt dann durch
        db.queryEntries(query, {schuhID: schuhID}); den Schuh zurück, der durch
        die query "selected" wird. Die geschweiften Klammern enthalten dabei den
        Parameter, der für den Platzhalter :schuhID eingesetzt wird. So kann
        dann der passende Eintrag an z.B. die form-controller.js geliefert
        werden. Am Ende ist die model.js also für alle Abfragen mit SQL
        zuständig und holt die passenden Daten aus der Datenbank.
      </p>
    </li>
    <li>
      <h2>Datenbankaufbau</h2>

      <ol class="list2">
        <p>
          Die Datenbank enthält bei uns fünf Tabellen, die verschiedene Daten
          verwalten. All diese Tabellen enthalten dann die Daten, die mittels
          SQL-Befehl durch die model.js abgerufen werden können.
        </p>
        <ul class="list3">
          <li>
            <p>
              baureihen: Enthält die nötigen Daten für die einzelnen Baureihen
            </p>
            <ul class="list4">
              <li>
                <p>baureiheID: Primärschlüssel und enthält ID der Baureihe</p>
              </li>
              <li>
                <p>
                  herstellerID: Hier wird die ID des Herstellers eingetragen,
                  die eine foreign Key zur Tabelle hersteller ist
                </p>
              </li>
              <li><p>baureiheName: Enthält den Namen der Baureihe</p></li>
              <li><p>baureiheImageLink: Enthält den Link des Bildes</p></li>
              <li>
                <p>baureiheDescriptionText: Enthält den Beschreibungstext</p>
              </li>
            </ul>
          </li>
          <li>
            <p>hersteller: Enthält die nötigen Daten für die Hersteller</p>
            <ul class="list4">
              <li>
                <p>
                  herstellerID: Enthält die ID des Herstelers und
                  Primärschlüssel
                </p>
              </li>
              <li><p>herstellerName: Enthält den Namen des Herstellers</p></li>
              <li><p>herstellerImageLink: Enthält den Link des Bildes</p></li>
              <li>
                <p>
                  herstellerText: Enthält den Beschreibungstext für den
                  Hersteller
                </p>
              </li>
            </ul>
          </li>
          <li>
            <p>schuh: Enthält die nötigen Daten für die Schuhe</p>
            <ul class="list4">
              <li>
                <p>schuhID: Enthält die ID des Schuhs und Primärschlüssel</p>
              </li>
              <li>
                <p>
                  baureiheID: Dort wird die ID der passenden Baureihe
                  eingetragen, Foreign Key zur baureiheID der Tabelle baureihe
                </p>
              </li>
              <li><p>schuhName: Enthält Name des Schuhs</p></li>
              <li><p>schuhImageLink: Enthält den Link des Bildes</p></li>
              <li>
                <p>schuhInfoText: Enthält den Beschreibungstext des Schuhs</p>
              </li>
              <li><p>kommentare: Enthält Kommentar zum Schuh</p></li>
            </ul>
          </li>
          <li>
            <p>sessions: Enthält die nötigen Daten für die Login-Session</p>
            <ul class="list4">
              <li>
                <p>
                  sessionID: Hier wird die ID der Session gespeichert,
                  Primärschlüssel
                </p>
              </li>
              <li>
                <p>
                  userEmail: Enthält die Email des Nuters, der eingelogt ist,
                  Foreign Key zu email aus der Tabelle userData
                </p>
              </li>
              <li>
                <p>
                  expirationDate: Enthält das Ablaufdatum an der die Session
                  automatisch endet
                </p>
              </li>
            </ul>
          </li>
          <li>
            <p>userData: Enthält die nötigen Daten für die Nutzer</p>
            <ul class="list4">
              <li>
                <p>userID: Hier wird die ID des Users gespeichert</p>
              </li>
              <li>
                <p>vorname: Enthält den Vornamen des Nutzers</p>
              </li>
              <li>
                <p>nachname: Enthält den Nachnamen des Nutzers</p>
              </li>
              <li>
                <p>
                  email: Enthält die email des Nutzers, die für den Login nötig
                  ist, Primärschlüssel
                </p>
              </li>
              <li>
                <p>
                  passwort: Enthält den Hashwert des Passworts, das der Nutzer
                  beim registrieren angegeben hat
                </p>
              </li>
              <li>
                <p>
                  admin: Enthält den Eintrag "admin", bei normalen Nutzern immer
                  auf Null
                </p>
              </li>
            </ul>
          </li>
        </ul>
        <p>
          All diese Daten in den Tabellen können durch die model.js abgerufen
          werden. Da diese Daten alle verändert werden können nutzen wir diese
          dann auf den HTML-Seiten, um die passenden Inhalte per Nunjucks dann
          anzuzeigen.
        </p>
      </ol>
    </li>
  </ol>
</main>

{%endblock%}
